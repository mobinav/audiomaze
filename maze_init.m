function X = maze_init(X)
% maze_init  intialize the audio maze and peripherals (mocap, lsl)
%
%   X = maze_init(X)
%
% state information returned in structure "X"
%
% maze_lines and maze_polygons are generated by a call to
% make_maze_polygons (for a random maze) or make_maze_polygons_nr (for a
% predetermined maze)

X.readFromLSL = true; % ***obsolete--used to switch away from datariver
%     X.functionHandle = [];
%     X.samplingRate  = 512;%512;
%     X.maxNumberOfFramesInAccumulatedData = 6000;% Inf;

%     X.overheads = [0,0]; % test, center of room
%     X.n_overheads = 1;
X.inTokenTol = .45; % 1/3m
X.outTokenTol = 1.5; % you must get this far away until you can replay

% flag for making sure the flourish message is only sent once
X.canFlourish = 0;

% 8/26/2016 DEM
% X.totalTimeNearWallHand = 0;
% X.totalTimeNearWallHead = 0;
% X.totalTimeTouchingWallHand = 0;
% X.totalTimeTouchingWallHead = 0;
% X.totalTimeInWallHand = 0;
% X.totalTimeInWallHead = 0;
% X.lingeringWallCntHand = 0;
% X.touchingWallCntHand = 0;
% X.touchingWallCntHead = 0;
% X.nearWallCntHand = 0;
% X.nearWallCntHead = 0;
% X.inWallCntHead = 0;
% X.inWallCntHand = 0;
% X.inWallCnt = 0;
 X.timeTotal = 0;

% determine the 'in wall' proximity threshold according to how max/msp
% understands it (midi units, 0-127)
% the proximity here is 0-1 (once we cross the near wall threshold) so
% we need to map MAX/msp's notion of in the wall to the audiomaze
% engine's notion
MAX_hand_wall_prox_thresh = 90; % got this from the MAX patch
X.hand_in_wall_prox = MAX_hand_wall_prox_thresh/127;

MAX_head_wall_prox_thresh = 90; % got this from the MAX patch
X.head_in_wall_prox = MAX_head_wall_prox_thresh/127;

%X.velocityPlot = figure(12);
% file to hold all the absolute values of velocity for grand total
%X.velocityFile = fopen('velocityFile', 'W');
% we'll store velocity and bonus in the X structure now.

% for mocap, specify mocap channel subset
X.mocap.firstChannel = 1; % first channel is events or should be ignored
X.mocap.lastChannel = nan; % use nan to make it until the last one that exist

X.mocap.doSimplePlot = true;

X.finished = 0;
X.nearWallAccumThresh = inf; %if near wall for this # seconds, warn: Feb 2017 JRI: 5->inf to disable

%% make the maze
X.am = audioMaze(X.mazeinfo.h, X.mazeinfo.w, X.mazeinfo.n_rows, X.mazeinfo.n_cols, X.mazeGeometry.maze_lines, X.mazeGeometry.maze_poly_wall, X.mazeGeometry.maze_poly_proximity);

X.am.plotMaze();
hold on;

%% vr world stuff
if X.doVrPlot == true
    if isfield(X, 'mocap') && isfield(X.mocap, 'mocapWorld') && ~isempty(X.mocap.mocapWorld)
        close(X.mocap.mocapWorld);
        delete(X.mocap.mocapWorld);
    end;
    cur_dir = pwd;
    vr_path = strcat(cur_dir,'\vr\minimal_with_axis_captions');
    mocapWorld = vrworld(vr_path, 'new');
    open(mocapWorld);
    
    X.mocap.mocapWorld = mocapWorld;
    X.mocap.roomWallCollection = vr_draw_maze(X.mocap.mocapWorld, X.am);
    
    figureHandle = view(X.mocap.mocapWorld);
    vrdrawnow;
end

%% initialize LSL, connect to MaxMSP (via patch lslreceive)
X = maze_init_LSL_outlets(X); % this function sets up all the LSL objects to send events to the audio engine

%% init input from phasespace
streaminfo = {};
disp('Waiting for Mocap stream...')
while isempty(streaminfo),
    streaminfo = lsl_resolve_byprop(X.LSL.lib,'type','Mocap',1); % look for mocap device
    drawnow
end
disp('Found Mocap Stream')
X.LSL.phasespace.streamInfo = streaminfo{1};
X.LSL.phasespace.inlet = lsl_inlet(X.LSL.phasespace.streamInfo);

%% define mocap markers
X = defineMocapMarkers(X);